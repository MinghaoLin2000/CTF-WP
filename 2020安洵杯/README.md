1. 蛮玄学的，先是so层的反调试，查看是否占用了23946端口，还有ptrace查看是否附加调试器，这步直接改寄存器跳过了，本来想直接nop的，发现有点小bug，就没深入了
2. 然后就是一个一波加密，但是感觉情况还是蛮多种的，首先首字符的acsii码模6，然后选择不同的加密，中间区别就是一个是加0，或1或2，这种，其他加密流程一样，这里我也是
随便试的，但是没跑出来，还是蛮奇怪的
3. 然后就是一个打乱顺序的哈希算法，这题数据有设计过，否则不可逆，请教了acm爷爷，也搞不出来，然后发现设计好的数据经过打乱顺序后，顺序没变
挂个失败的脚本，具体等wp出来再看看。
```
c=[0x64, 0xDD, 0x16, 0x8E, 0x40, 0x41, 0xCD, 0xCF, 0x94, 0x09, 0xAA, 0x6C, 0x0C, 0xE9, 0x72, 0x6F, 0x88, 0x69, 0xB0, 0xEF]
v9=[0xAA,0xBB,0xCC,0xDD]
v10=[0xB1,0x27,0x39,0x1F,0x4D,0x87,0xED]
v11=[0x10,0x44,0x35,0xA7,0x82,0x43,0x91]
v12=[0xC5,0x28,0x96,0xB7,0x21,0xDD,0xF3]
c[19]=(c[19]^c[4])&0xff
for i in range(14):
    c[i]=(c[i]^v11[i%7])&0xff
c[4]-=5
for j in range(4):
    c[j]-=1
    c[j]=(c[j]^v9[j])&0xff
flag=""
for k in range(len(c)):
    print(chr(c[k]%128),end="")
```