# 前言
之前在看雪发现有师傅发了这篇的详细wp，我也没细看，听说出的不错，我就来试试了233，总体感觉不是很难，但是出题人是真的骚，这种欺骗的出题手法，还隐藏的这么好，实属难得，给出题人点个赞，算法部分其实不是很难理解，魔改了rc4和base64，只要对这两个算法加密流程熟悉的话，没啥大毛病。考了一些jni开发的东西，感觉真的很不错

# 切入正题
1. apk用jeb打开，看了下主配置文件，只有一个活动，点开那个活动看看
![avatar](https://img2020.cnblogs.com/blog/2021287/202011/2021287-20201116010712153-1739692197.png)
发现这里新建了一个handler对象，handler其实之前看一行代码书里的服务那节有碰到，就是新建一个子进程，但是子进程无法更改ui，所以通过消息机制，通知主进程去修改ui的手法，这里也不是很重要，后面跟着这个逻辑，一直error，我也迷了，后面看了其他师傅的wp，才发现它这个活动继承的类名不对，居然是自己自定义的
2. 发现端倪
![avatar](https://img2020.cnblogs.com/blog/2021287/202011/2021287-20201116010809669-611469409.png)
太坑了，也就是有可能这个活动把自定义的类里面的某些方法给继承下来了，而且这个方法魔改了oncreate方法，打开这个活动
3. 新大陆
![avatar](https://img2020.cnblogs.com/blog/2021287/202011/2021287-20201116010746380-1793792410.png)
发现里面onStart()方法被重写了，并重新实现了那个按钮的点击事件，因为onStart（）方法是在onCreate（）方法后面执行的，所以点击事件就被顶替修改了，这里逻辑蛮简单的，主要就是password经过了一个native函数的加密，只有正确的password才能弹出flag，
4. ida出现
这里找关键函数，还有点曲折，不过我还是找到了，因为安卓jni开发，我还是整的蛮熟练的，Jninativemethod这个结构体，我上面就是找它，直接就找到了，不过正确的方式是去找registNative函数，因为动态注册jni_onload函数，主要是调用这个函数结合那个结构体进行动态注册的，所以把里面的类型改成JNIEnv* ，ida就能识别出来了，这里切到关键逻辑这里。
![avatar](https://img2020.cnblogs.com/blog/2021287/202011/2021287-20201116010848827-1882220355.png)
这里是rc4初始化t向量的地方，256次数的循环，太明显了。2333
rc4魔改的地方在于s盒初始化不是直接的0.。xx这种，而且自己实现了个s盒
，其他过程都一样
![avatar](https://img2020.cnblogs.com/blog/2021287/202011/2021287-20201116010917908-1680011767.png)
这里就是常规的rc4加密，然后base64换表加密，不过坑的是第一个和第三个字符，是有分别异或0xf和7的，所以这里要注意一下，可以动调的时候观察就观察出来了

5. wp
```
import base64
#原表
initbase64table="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
#魔改后的表
diybase64table="!:#$%&()+-*/`~_[]{}?<>,.@^abcdefghijklmnopqrstuvwxyz0123456789\\';"
sbox = [0xf0,0x37,0xe1,0x9b,0x2a,0x15,0x17,0x9f,0xd7,0x58,0x4d,0x6e,0x33,0xa0,0x39,0xae,0x4,0xd0,0xbe,0xed,0xf8,0x66,0x5e,0x0,0xd6,0x91,0x2f,0xc3,0x10,0x4c,0xf7,0xa6,0xc1,0xec,0x6d,0xb,0x50,0x65,0xbb,0x34,0xfa,0xa4,0x2d,0x3b,0x23,0xa1,0x96,0xd5,0x1d,0x38,0x56,0xa,0x5d,0x4f,0xe4,0xcc,0x24,0xd,0x12,0x87,0x35,0x85,0x8e,0x6f,0xc6,0x13,0x9a,0xd3,0xfc,0xe7,0x8,0xac,0xb7,0xe9,0xb0,0xe8,0x41,0xaa,0x55,0x53,0xc2,0x42,0xbc,0xe6,0xf,0x8a,0x86,0xa8,0xcf,0x84,0xc5,0x48,0x74,0x36,0x7,0xeb,0x88,0x51,0xf6,0x7f,0x57,0x5,0x63,0x3e,0xfe,0xb8,0xc9,0xf5,0xaf,0xdf,0xea,0x82,0x44,0xf9,0xcd,0x6,0xba,0x30,0x47,0x40,0xde,0xfd,0x1c,0x7c,0x11,0x5c,0x2,0x31,0x2c,0x9c,0x5f,0x46,0x27,0xc4,0x83,0x73,0x16,0x90,0x20,0x76,0x7b,0xf2,0xe3,0xf3,0x77,0x52,0x80,0x25,0x9,0x26,0x3f,0xc7,0x18,0x1b,0xa3,0xff,0xfb,0xcb,0xa9,0x8c,0x54,0x7a,0x68,0xb4,0x70,0x4b,0xe2,0x49,0x22,0x7e,0xa5,0xb6,0x81,0x9d,0x4e,0x67,0xf1,0xa7,0x3c,0xd9,0x94,0xef,0x32,0x6b,0x1f,0xb1,0x60,0xb9,0x64,0x59,0x1,0xb3,0x7d,0xe0,0x6c,0xad,0x97,0x19,0xb5,0x3a,0xf4,0xd8,0x8d,0x98,0x3,0x93,0x1a,0xdc,0x1e,0x4a,0xc0,0x5a,0xe5,0xd1,0x3d,0x14,0xc8,0x79,0xbd,0x43,0xdb,0x69,0xd2,0x61,0x95,0x9e,0x21,0x45,0x89,0x2b,0xab,0x29,0xa2,0x8b,0x2e,0xd4,0xe,0x62,0xca,0x28,0xda,0x5b,0x72,0x8f,0x99,0x75,0xee,0x78,0xc,0x71,0xbf,0xdd,0xce,0x92,0x6a,0xb2]

finalc=" {9*8ga*l!Tn?@#fj'j$\g;;"
def base64decode():
  encode_flag1=[]
  for i in range(len(finalc)):
    if i%4==0:
      bit=7
    elif i%4==2 and finalc[i]!=';':
      bit=0xf
    else:
      bit=0
    encode_flag1.append(chr(ord(finalc[i])^bit))
  encode_flag2 = ''.join(encode_flag1).translate(''.maketrans(diybase64table, initbase64table))
  return base64.b64decode(encode_flag2)

def rc4decrypt(s):
  i = 0
  j = 0
  ss = []
  for k in range(len(s)):
    i = (i + 1) % 256
    j = (j + sbox[i]) % 256
    sbox[i], sbox[j] = sbox[j], sbox[i]
    index = (sbox[i] + sbox[j]) % 256
    ss.append(chr(s[k] ^ sbox[index]))
  print(''.join(ss))
rc4decrypt(base64decode())
```

6. 总结


开发才是正道，其次jni是先执行init_array的，ctrl+s就可以选择init_array,发现调用了一个函数，原来是把表给修改了，这里幸亏我是动调弄的，所以没有受到影响，静态的话就掉坑里了。